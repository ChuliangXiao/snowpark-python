from typing import Any, Dict, Iterable, Iterator, List, Optional, Tuple, Union

import snowflake.snowpark
from snowflake.connector.options import pandas
from snowflake.snowpark._internal.analyzer.binary_plan_node import JoinType as JoinType
from snowflake.snowpark._internal.analyzer.expression import Expression as Expression
from snowflake.snowpark._internal.analyzer.snowflake_plan_node import (
    LogicalPlan as LogicalPlan,
)
from snowflake.snowpark._internal.analyzer.table_function import (
    TableFunctionExpression as TableFunctionExpression,
)
from snowflake.snowpark._internal.analyzer.unary_plan_node import ViewType as ViewType
from snowflake.snowpark._internal.type_utils import (
    ColumnOrName as ColumnOrName,
    ColumnOrSqlExpr as ColumnOrSqlExpr,
    LiteralType as LiteralType,
)
from snowflake.snowpark.column import Column
from snowflake.snowpark.dataframe_na_functions import DataFrameNaFunctions
from snowflake.snowpark.dataframe_stat_functions import DataFrameStatFunctions
from snowflake.snowpark.dataframe_writer import DataFrameWriter
from snowflake.snowpark.row import Row as Row
from snowflake.snowpark.types import StructType

logger: Any

class DataFrame:
    is_cached: Any
    approxQuantile: Any
    corr: Any
    cov: Any
    crosstab: Any
    sampleBy: Any
    dropna: Any
    fillna: Any
    replace: Any
    def __init__(
        self,
        session: Optional[snowflake.snowpark.Session] = ...,
        plan: Optional[LogicalPlan] = ...,
        is_cached: bool = ...,
    ) -> None: ...
    @property
    def stat(self) -> DataFrameStatFunctions: ...
    def collect(self) -> List[Row]: ...
    def to_local_iterator(self) -> Iterator[Row]: ...
    def __copy__(self) -> DataFrame: ...
    def to_pandas(self, **kwargs) -> pandas.DataFrame: ...
    def to_pandas_batches(self, **kwargs) -> Iterator[pandas.DataFrame]: ...
    def to_df(self, *names: Union[str, Iterable[str]]) -> DataFrame: ...
    def __getitem__(self, item): ...
    def __getattr__(self, name): ...
    @property
    def columns(self) -> List[str]: ...
    def col(self, col_name: str) -> Column: ...
    def select(
        self, *cols: Union[ColumnOrName, Iterable[ColumnOrName]]
    ) -> DataFrame: ...
    def select_expr(self, *exprs: Union[str, Iterable[str]]) -> DataFrame: ...
    selectExpr: Any
    def drop(self, *cols: Union[ColumnOrName, Iterable[ColumnOrName]]) -> DataFrame: ...
    def filter(self, expr: ColumnOrSqlExpr) -> DataFrame: ...
    def sort(
        self,
        *cols: Union[ColumnOrName, Iterable[ColumnOrName]],
        ascending: Optional[Union[bool, int, List[Union[bool, int]]]] = ...
    ) -> DataFrame: ...
    def agg(
        self,
        exprs: Union[
            Column, Tuple[str, str], List[Column], List[Tuple[str, str]], Dict[str, str]
        ],
    ) -> DataFrame: ...
    def rollup(
        self, *cols: Union[ColumnOrName, Iterable[ColumnOrName]]
    ) -> snowflake.snowpark.RelationalGroupedDataFrame: ...
    def group_by(
        self, *cols: Iterable[ColumnOrName]
    ) -> snowflake.snowpark.RelationalGroupedDataFrame: ...
    def group_by_grouping_sets(
        self,
        *grouping_sets: Union[
            snowflake.snowpark.GroupingSets, Iterable[snowflake.snowpark.GroupingSets]
        ]
    ) -> snowflake.snowpark.RelationalGroupedDataFrame: ...
    def cube(
        self, *cols: Union[ColumnOrName, Iterable[ColumnOrName]]
    ) -> snowflake.snowpark.RelationalGroupedDataFrame: ...
    def distinct(self) -> DataFrame: ...
    def drop_duplicates(self, *subset: Union[str, Iterable[str]]) -> DataFrame: ...
    def pivot(
        self, pivot_col: ColumnOrName, values: Iterable[LiteralType]
    ) -> snowflake.snowpark.RelationalGroupedDataFrame: ...
    def unpivot(
        self, value_column: str, name_column: str, column_list: List[ColumnOrName]
    ) -> DataFrame: ...
    def limit(self, n: int) -> DataFrame: ...
    def union(self, other: DataFrame) -> DataFrame: ...
    def union_all(self, other: DataFrame) -> DataFrame: ...
    def union_by_name(self, other: DataFrame) -> DataFrame: ...
    def union_all_by_name(self, other: DataFrame) -> DataFrame: ...
    def intersect(self, other: DataFrame) -> DataFrame: ...
    def except_(self, other: DataFrame) -> DataFrame: ...
    def natural_join(
        self, right: DataFrame, join_type: Optional[str] = ...
    ) -> DataFrame: ...
    def join(
        self,
        right: DataFrame,
        using_columns: Optional[Union[ColumnOrName, List[ColumnOrName]]] = ...,
        join_type: Optional[str] = ...,
    ) -> DataFrame: ...
    def join_table_function(
        self,
        func_name: Union[str, Iterable[str]],
        *func_arguments: ColumnOrName,
        **func_named_arguments: ColumnOrName
    ) -> DataFrame: ...
    def cross_join(self, right: DataFrame) -> DataFrame: ...
    def with_column(self, col_name: str, col: Column) -> DataFrame: ...
    def with_columns(self, col_names: List[str], values: List[Column]) -> DataFrame: ...
    def count(self) -> int: ...
    @property
    def write(self) -> DataFrameWriter: ...
    def copy_into_table(
        self,
        table_name: Union[str, Iterable[str]],
        *,
        files: Optional[Iterable[str]] = ...,
        pattern: Optional[str] = ...,
        validation_mode: Optional[str] = ...,
        target_columns: Optional[Iterable[str]] = ...,
        transformations: Optional[Iterable[ColumnOrName]] = ...,
        format_type_options: Optional[Dict[str, Any]] = ...,
        **copy_options: Any
    ) -> List[Row]: ...
    def show(self, n: int = ..., max_width: int = ...) -> None: ...
    def flatten(
        self,
        input: ColumnOrName,
        path: Optional[str] = ...,
        outer: bool = ...,
        recursive: bool = ...,
        mode: str = ...,
    ) -> DataFrame: ...
    def create_or_replace_view(self, name: Union[str, Iterable[str]]) -> List[Row]: ...
    def create_or_replace_temp_view(
        self, name: Union[str, Iterable[str]]
    ) -> List[Row]: ...
    def first(self, n: Optional[int] = ...) -> Union[Optional[Row], List[Row]]: ...
    take: Any
    def sample(
        self, frac: Optional[float] = ..., n: Optional[int] = ...
    ) -> DataFrame: ...
    @property
    def na(self) -> DataFrameNaFunctions: ...
    def describe(self, *cols: Union[str, List[str]]) -> DataFrame: ...
    def with_column_renamed(self, existing: ColumnOrName, new: str) -> DataFrame: ...
    def cache_result(self) -> DataFrame: ...
    def random_split(
        self, weights: List[float], seed: Optional[int] = ...
    ) -> List[DataFrame]: ...
    @property
    def queries(self) -> Dict[str, List[str]]: ...
    def explain(self) -> None: ...
    def schema(self) -> StructType: ...
    where: Any
    approx_quantile: Any
    sample_by: Any
    createOrReplaceTempView: Any
    createOrReplaceView: Any
    crossJoin: Any
    dropDuplicates: Any
    groupBy: Any
    minus: Any
    subtract: Any
    toDF: Any
    toPandas: Any
    unionAll: Any
    unionAllByName: Any
    unionByName: Any
    withColumn: Any
    withColumnRenamed: Any
    toLocalIterator: Any
    randomSplit: Any
    rename: Any
