import functools
from types import ModuleType
from typing import Callable, Iterable, List, Optional, Tuple, Union, overload

import snowflake.snowpark
from snowflake.snowpark._internal.type_utils import (
    ColumnOrLiteral as ColumnOrLiteral,
    ColumnOrLiteralStr as ColumnOrLiteralStr,
    ColumnOrName as ColumnOrName,
    ColumnOrSqlExpr as ColumnOrSqlExpr,
    LiteralType as LiteralType,
)
from snowflake.snowpark.column import CaseExpr, Column
from snowflake.snowpark.stored_procedure import StoredProcedure as StoredProcedure
from snowflake.snowpark.types import DataType as DataType
from snowflake.snowpark.udf import UserDefinedFunction as UserDefinedFunction

def col(col_name: str) -> Column: ...
def column(col_name: str) -> Column: ...
def lit(literal: LiteralType) -> Column: ...
def sql_expr(sql: str) -> Column: ...
def current_session() -> Column: ...
def current_statement() -> Column: ...
def current_user() -> Column: ...
def current_version() -> Column: ...
def current_warehouse() -> Column: ...
def current_database() -> Column: ...
def current_role() -> Column: ...
def current_schema() -> Column: ...
def current_schemas() -> Column: ...
def current_region() -> Column: ...
def current_available_roles() -> Column: ...
def add_months(
    date_or_timestamp: ColumnOrName, number_of_months: Union[Column, int]
): ...
def any_value(e: ColumnOrName): ...
def bitnot(e: ColumnOrName): ...
def bitshiftleft(to_shift_column: ColumnOrName, n: Union[Column, int]): ...
def bitshiftright(to_shift_column: ColumnOrName, n: Union[Column, int]): ...
def convert_timezone(
    target_timezone: ColumnOrName,
    source_time: ColumnOrName,
    source_timezone: Optional[ColumnOrName] = ...,
): ...
def approx_count_distinct(e: ColumnOrName) -> Column: ...
def avg(e: ColumnOrName) -> Column: ...
def corr(column1: ColumnOrName, column2: ColumnOrName) -> Column: ...
def count(e: ColumnOrName) -> Column: ...
def count_distinct(*cols: ColumnOrName) -> Column: ...

countDistinct = count_distinct

def covar_pop(column1: ColumnOrName, column2: ColumnOrName) -> Column: ...
def covar_samp(column1: ColumnOrName, column2: ColumnOrName) -> Column: ...
def kurtosis(e: ColumnOrName) -> Column: ...
def max(e: ColumnOrName) -> Column: ...
def mean(e: ColumnOrName) -> Column: ...
def median(e: ColumnOrName) -> Column: ...
def min(e: ColumnOrName) -> Column: ...
def mode(e: ColumnOrName) -> Column: ...
def skew(e: ColumnOrName) -> Column: ...
def stddev(e: ColumnOrName) -> Column: ...
def stddev_samp(e: ColumnOrName) -> Column: ...
def stddev_pop(e: ColumnOrName) -> Column: ...
def sum(e: ColumnOrName) -> Column: ...
def sum_distinct(e: ColumnOrName) -> Column: ...
def variance(e: ColumnOrName) -> Column: ...
def var_samp(e: ColumnOrName) -> Column: ...
def var_pop(e: ColumnOrName) -> Column: ...
def approx_percentile(col: ColumnOrName, percentile: float) -> Column: ...
def approx_percentile_accumulate(col: ColumnOrName) -> Column: ...
def approx_percentile_estimate(state: ColumnOrName, percentile: float) -> Column: ...
def approx_percentile_combine(state: ColumnOrName) -> Column: ...
def grouping(*cols: ColumnOrName) -> Column: ...

grouping_id = grouping

def coalesce(*e: ColumnOrName) -> Column: ...
def equal_nan(e: ColumnOrName) -> Column: ...
def is_null(e: ColumnOrName) -> Column: ...
def negate(e: ColumnOrName) -> Column: ...
def not_(e: ColumnOrName) -> Column: ...
def random(seed: Optional[int] = ...) -> Column: ...
def uniform(
    min_: Union[ColumnOrName, int, float],
    max_: Union[ColumnOrName, int, float],
    gen: Union[ColumnOrName, int, float],
) -> Column: ...
def to_decimal(e: ColumnOrName, precision: int, scale: int) -> Column: ...
def div0(
    dividend: Union[ColumnOrName, int, float], divisor: Union[ColumnOrName, int, float]
) -> Column: ...
def sqrt(e: ColumnOrName) -> Column: ...
def abs(e: ColumnOrName) -> Column: ...
def acos(e: ColumnOrName) -> Column: ...
def asin(e: ColumnOrName) -> Column: ...
def atan(e: ColumnOrName) -> Column: ...
def atan2(y: ColumnOrName, x: ColumnOrName) -> Column: ...
def ceil(e: ColumnOrName) -> Column: ...
def cos(e: ColumnOrName) -> Column: ...
def cosh(e: ColumnOrName) -> Column: ...
def exp(e: ColumnOrName) -> Column: ...
def factorial(e: ColumnOrName) -> Column: ...
def floor(e: ColumnOrName) -> Column: ...
def sin(e: ColumnOrName) -> Column: ...
def sinh(e: ColumnOrName) -> Column: ...
def tan(e: ColumnOrName) -> Column: ...
def tanh(e: ColumnOrName) -> Column: ...
def degrees(e: ColumnOrName) -> Column: ...
def radians(e: ColumnOrName) -> Column: ...
def md5(e: ColumnOrName) -> Column: ...
def sha1(e: ColumnOrName) -> Column: ...
def sha2(e: ColumnOrName, num_bits: int) -> Column: ...
def hash(e: ColumnOrName) -> Column: ...
def ascii(e: ColumnOrName) -> Column: ...
def initcap(e: ColumnOrName) -> Column: ...
def length(e: ColumnOrName) -> Column: ...
def lower(e: ColumnOrName) -> Column: ...
def lpad(e: ColumnOrName, len: Union[Column, int], pad: ColumnOrName) -> Column: ...
def ltrim(e: ColumnOrName, trim_string: Optional[ColumnOrName] = ...) -> Column: ...
def rpad(e: ColumnOrName, len: Union[Column, int], pad: ColumnOrName) -> Column: ...
def rtrim(e: ColumnOrName, trim_string: Optional[ColumnOrName] = ...) -> Column: ...
def repeat(s: ColumnOrName, n: Union[Column, int]) -> Column: ...
def soundex(e: ColumnOrName) -> Column: ...
def trim(e: ColumnOrName, trim_string: ColumnOrName) -> Column: ...
def upper(e: ColumnOrName) -> Column: ...
def strtok_to_array(
    text: ColumnOrName, delimiter: Optional[ColumnOrName] = ...
) -> Column: ...
def log(
    base: Union[ColumnOrName, int, float], x: Union[ColumnOrName, int, float]
) -> Column: ...
def pow(
    l: Union[ColumnOrName, int, float], r: Union[ColumnOrName, int, float]
) -> Column: ...
def round(e: ColumnOrName, scale: Union[ColumnOrName, int, float] = ...) -> Column: ...
def split(str: ColumnOrName, pattern: ColumnOrName) -> Column: ...
def substring(
    str: ColumnOrName, pos: Union[Column, int], len: Union[Column, int]
) -> Column: ...

substr = substring

def regexp_count(
    subject: ColumnOrName,
    pattern: ColumnOrLiteralStr,
    position: Union[Column, int] = ...,
    *parameters: ColumnOrLiteral
) -> Column: ...
def regexp_replace(
    subject: ColumnOrName,
    pattern: ColumnOrLiteralStr,
    replacement: ColumnOrLiteralStr = ...,
    position: Union[Column, int] = ...,
    occurrences: Union[Column, int] = ...,
    *parameters: ColumnOrLiteral
) -> Column: ...
def replace(
    subject: ColumnOrName,
    pattern: ColumnOrLiteralStr,
    replacement: ColumnOrLiteralStr = ...,
) -> Column: ...
def charindex(
    target_expr: ColumnOrName,
    source_expr: ColumnOrName,
    position: Optional[Union[Column, int]] = ...,
) -> Column: ...
def collate(e: Column, collation_spec: str) -> Column: ...
def collation(e: ColumnOrName) -> Column: ...
def concat(*cols: ColumnOrName) -> Column: ...
def concat_ws(*cols: ColumnOrName) -> Column: ...
def translate(
    src: ColumnOrName, matching_string: ColumnOrName, replace_string: ColumnOrName
) -> Column: ...
def contains(col: ColumnOrName, string: ColumnOrName) -> Column: ...
def startswith(col: ColumnOrName, str: ColumnOrName) -> Column: ...
def endswith(col: ColumnOrName, str: ColumnOrName) -> Column: ...
def insert(
    base_expr: ColumnOrName,
    position: Union[Column, int],
    length: Union[Column, int],
    insert_expr: ColumnOrName,
) -> Column: ...
def left(str_expr: ColumnOrName, length: Union[Column, int]) -> Column: ...
def right(str_expr: ColumnOrName, length: Union[Column, int]) -> Column: ...
def char(col: ColumnOrName) -> Column: ...
def to_char(c: ColumnOrName, format: Optional[ColumnOrLiteralStr] = ...) -> Column: ...

to_varchar = to_char

def to_time(e: ColumnOrName, fmt: Optional[Column] = ...) -> Column: ...
def to_timestamp(e: ColumnOrName, fmt: Optional[Column] = ...) -> Column: ...
def to_date(e: ColumnOrName, fmt: Optional[Column] = ...) -> Column: ...
def current_timestamp() -> Column: ...
def current_date() -> Column: ...
def current_time() -> Column: ...
def hour(e: ColumnOrName) -> Column: ...
def last_day(e: ColumnOrName) -> Column: ...
def minute(e: ColumnOrName) -> Column: ...
def next_day(date: ColumnOrName, day_of_week: ColumnOrLiteral) -> Column: ...
def previous_day(date: ColumnOrName, day_of_week: ColumnOrLiteral) -> Column: ...
def second(e: ColumnOrName) -> Column: ...
def month(e: ColumnOrName) -> Column: ...
def monthname(e: ColumnOrName) -> Column: ...
def quarter(e: ColumnOrName) -> Column: ...
def year(e: ColumnOrName) -> Column: ...
def sysdate() -> Column: ...
def months_between(date1: ColumnOrName, date2: ColumnOrName) -> Column: ...
def to_geography(e: ColumnOrName) -> Column: ...
def arrays_overlap(array1: ColumnOrName, array2: ColumnOrName) -> Column: ...
def array_intersection(array1: ColumnOrName, array2: ColumnOrName) -> Column: ...
def datediff(part: str, col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def trunc(e: ColumnOrName, scale: Union[ColumnOrName, int, float] = ...) -> Column: ...
def dateadd(part: str, col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def date_from_parts(y: ColumnOrName, m: ColumnOrName, d: ColumnOrName) -> Column: ...
def date_trunc(part: ColumnOrName, expr: ColumnOrName) -> Column: ...
def dayname(e: ColumnOrName) -> Column: ...
def dayofmonth(e: ColumnOrName) -> Column: ...
def dayofweek(e: ColumnOrName) -> Column: ...
def dayofyear(e: ColumnOrName) -> Column: ...
def is_array(col: ColumnOrName) -> Column: ...
def is_boolean(col: ColumnOrName) -> Column: ...
def is_binary(col: ColumnOrName) -> Column: ...
def is_char(col: ColumnOrName) -> Column: ...
def is_varchar(col: ColumnOrName) -> Column: ...
def is_date(col: ColumnOrName) -> Column: ...
def is_date_value(col: ColumnOrName) -> Column: ...
def is_decimal(col: ColumnOrName) -> Column: ...
def is_double(col: ColumnOrName) -> Column: ...
def is_real(col: ColumnOrName) -> Column: ...
def is_integer(col: ColumnOrName) -> Column: ...
def is_null_value(col: ColumnOrName) -> Column: ...
def is_object(col: ColumnOrName) -> Column: ...
def is_time(col: ColumnOrName) -> Column: ...
def is_timestamp_ltz(col: ColumnOrName) -> Column: ...
def is_timestamp_ntz(col: ColumnOrName) -> Column: ...
def is_timestamp_tz(col: ColumnOrName) -> Column: ...
def time_from_parts(
    hour: Union[ColumnOrName, int],
    minute: Union[ColumnOrName, int],
    second: Union[ColumnOrName, int],
    nanoseconds: Optional[Union[ColumnOrName, int]] = ...,
) -> Column: ...
@overload
def timestamp_from_parts(
    date_expr: ColumnOrName, time_expr: ColumnOrName
) -> Column: ...
@overload
def timestamp_from_parts(
    year: Union[ColumnOrName, int],
    month: Union[ColumnOrName, int],
    day: Union[ColumnOrName, int],
    hour: Union[ColumnOrName, int],
    minute: Union[ColumnOrName, int],
    second: Union[ColumnOrName, int],
    nanosecond: Optional[Union[ColumnOrName, int]] = ...,
    timezone: Optional[ColumnOrLiteralStr] = ...,
) -> Column: ...
def timestamp_ltz_from_parts(
    year: Union[ColumnOrName, int],
    month: Union[ColumnOrName, int],
    day: Union[ColumnOrName, int],
    hour: Union[ColumnOrName, int],
    minute: Union[ColumnOrName, int],
    second: Union[ColumnOrName, int],
    nanoseconds: Optional[Union[ColumnOrName, int]] = ...,
) -> Column: ...
@overload
def timestamp_ntz_from_parts(
    date_expr: ColumnOrName, time_expr: ColumnOrName
) -> Column: ...
@overload
def timestamp_ntz_from_parts(
    year: Union[ColumnOrName, int],
    month: Union[ColumnOrName, int],
    day: Union[ColumnOrName, int],
    hour: Union[ColumnOrName, int],
    minute: Union[ColumnOrName, int],
    second: Union[ColumnOrName, int],
    nanosecond: Optional[Union[ColumnOrName, int]] = ...,
) -> Column: ...
def timestamp_tz_from_parts(
    year: Union[ColumnOrName, int],
    month: Union[ColumnOrName, int],
    day: Union[ColumnOrName, int],
    hour: Union[ColumnOrName, int],
    minute: Union[ColumnOrName, int],
    second: Union[ColumnOrName, int],
    nanoseconds: Optional[Union[ColumnOrName, int]] = ...,
    timezone: Optional[ColumnOrLiteralStr] = ...,
) -> Column: ...
def weekofyear(e: ColumnOrName) -> Column: ...
def typeof(col: ColumnOrName) -> Column: ...
def check_json(col: ColumnOrName) -> Column: ...
def check_xml(col: ColumnOrName) -> Column: ...
def json_extract_path_text(col: ColumnOrName, path: ColumnOrName) -> Column: ...
def parse_json(e: ColumnOrName) -> Column: ...
def parse_xml(e: ColumnOrName) -> Column: ...
def strip_null_value(col: ColumnOrName) -> Column: ...
def array_agg(col: ColumnOrName, is_distinct: bool = ...) -> Column: ...
def array_append(array: ColumnOrName, element: ColumnOrName) -> Column: ...
def array_cat(array1: ColumnOrName, array2: ColumnOrName) -> Column: ...
def array_compact(array: ColumnOrName) -> Column: ...
def array_construct(*cols: ColumnOrName) -> Column: ...
def array_construct_compact(*cols: ColumnOrName) -> Column: ...
def array_contains(variant: ColumnOrName, array: ColumnOrName) -> Column: ...
def array_insert(
    array: ColumnOrName, pos: ColumnOrName, element: ColumnOrName
) -> Column: ...
def array_position(variant: ColumnOrName, array: ColumnOrName) -> Column: ...
def array_prepend(array: ColumnOrName, element: ColumnOrName) -> Column: ...
def array_size(array: ColumnOrName) -> Column: ...
def array_slice(
    array: ColumnOrName, from_: ColumnOrName, to: ColumnOrName
) -> Column: ...
def array_to_string(array: ColumnOrName, separator: ColumnOrName) -> Column: ...
def object_agg(key: ColumnOrName, value: ColumnOrName) -> Column: ...
def object_construct(*key_values: ColumnOrName) -> Column: ...
def object_construct_keep_null(*key_values: ColumnOrName) -> Column: ...
def object_delete(
    obj: ColumnOrName, key1: ColumnOrName, *keys: ColumnOrName
) -> Column: ...
def object_insert(
    obj: ColumnOrName,
    key: ColumnOrName,
    value: ColumnOrName,
    update_flag: Optional[ColumnOrName] = ...,
) -> Column: ...
def object_pick(obj: ColumnOrName, key1: ColumnOrName, *keys: ColumnOrName): ...
def as_array(variant: ColumnOrName) -> Column: ...
def as_binary(variant: ColumnOrName) -> Column: ...
def as_char(variant: ColumnOrName) -> Column: ...
def as_varchar(variant: ColumnOrName) -> Column: ...
def as_date(variant: ColumnOrName) -> Column: ...
def cast(column: ColumnOrName, to: Union[str, DataType]) -> Column: ...
def try_cast(column: ColumnOrName, to: Union[str, DataType]) -> Column: ...
def as_decimal(
    variant: ColumnOrName, precision: Optional[int] = ..., scale: Optional[int] = ...
) -> Column: ...
def as_number(
    variant: ColumnOrName, precision: Optional[int] = ..., scale: Optional[int] = ...
) -> Column: ...
def as_double(variant: ColumnOrName) -> Column: ...
def as_real(variant: ColumnOrName) -> Column: ...
def as_integer(variant: ColumnOrName) -> Column: ...
def as_object(variant: ColumnOrName) -> Column: ...
def as_time(variant: ColumnOrName) -> Column: ...
def as_timestamp_ltz(variant: ColumnOrName) -> Column: ...
def as_timestamp_ntz(variant: ColumnOrName) -> Column: ...
def as_timestamp_tz(variant: ColumnOrName) -> Column: ...
def to_binary(e: ColumnOrName, fmt: Optional[str] = ...) -> Column: ...
def to_array(e: ColumnOrName) -> Column: ...
def to_json(e: ColumnOrName) -> Column: ...
def to_object(e: ColumnOrName) -> Column: ...
def to_variant(e: ColumnOrName) -> Column: ...
def to_xml(e: ColumnOrName) -> Column: ...
def get_ignore_case(obj: ColumnOrName, field: ColumnOrName) -> Column: ...
def object_keys(obj: ColumnOrName) -> Column: ...
def xmlget(
    xml: ColumnOrName, tag: ColumnOrName, instance_num: Union[ColumnOrName, int] = ...
) -> Column: ...
def get_path(col: ColumnOrName, path: ColumnOrName) -> Column: ...
def get(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def when(condition: ColumnOrSqlExpr, value: Union[ColumnOrLiteral]) -> CaseExpr: ...
def iff(
    condition: ColumnOrSqlExpr,
    expr1: Union[ColumnOrLiteral],
    expr2: Union[ColumnOrLiteral],
) -> Column: ...
def in_(
    cols: List[ColumnOrName],
    *vals: Union[snowflake.snowpark.DataFrame, ColumnOrLiteral, List[ColumnOrLiteral]]
) -> Column: ...
def cume_dist() -> Column: ...
def rank() -> Column: ...
def percent_rank() -> Column: ...
def dense_rank() -> Column: ...
def row_number() -> Column: ...
def lag(
    e: ColumnOrName,
    offset: int = ...,
    default_value: Optional[Union[ColumnOrLiteral]] = ...,
    ignore_nulls: bool = ...,
) -> Column: ...
def lead(
    e: ColumnOrName,
    offset: int = ...,
    default_value: Optional[Union[Column, LiteralType]] = ...,
    ignore_nulls: bool = ...,
) -> Column: ...
def ntile(e: ColumnOrName) -> Column: ...
def percentile_cont(percentile: float) -> Column: ...
def greatest(*columns: ColumnOrName) -> Column: ...
def least(*columns: ColumnOrName) -> Column: ...
def listagg(
    e: ColumnOrName, delimiter: str = ..., is_distinct: bool = ...
) -> Column: ...
def when_matched(
    condition: Optional[Column] = ...,
) -> snowflake.snowpark.table.WhenMatchedClause: ...
def when_not_matched(
    condition: Optional[Column] = ...,
) -> snowflake.snowpark.table.WhenNotMatchedClause: ...
def udf(
    func: Optional[Callable] = ...,
    *,
    return_type: Optional[DataType] = ...,
    input_types: Optional[List[DataType]] = ...,
    name: Optional[Union[str, Iterable[str]]] = ...,
    is_permanent: bool = ...,
    stage_location: Optional[str] = ...,
    imports: Optional[List[Union[str, Tuple[str, str]]]] = ...,
    packages: Optional[List[Union[str, ModuleType]]] = ...,
    replace: bool = ...,
    session: Optional[snowflake.snowpark.session.Session] = ...,
    parallel: int = ...,
    max_batch_size: Optional[int] = ...
) -> Union[UserDefinedFunction, functools.partial]: ...
def pandas_udf(
    func: Optional[Callable] = ...,
    *,
    return_type: Optional[DataType] = ...,
    input_types: Optional[List[DataType]] = ...,
    name: Optional[Union[str, Iterable[str]]] = ...,
    is_permanent: bool = ...,
    stage_location: Optional[str] = ...,
    imports: Optional[List[Union[str, Tuple[str, str]]]] = ...,
    packages: Optional[List[Union[str, ModuleType]]] = ...,
    replace: bool = ...,
    session: Optional[snowflake.snowpark.session.Session] = ...,
    parallel: int = ...,
    max_batch_size: Optional[int] = ...
) -> Union[UserDefinedFunction, functools.partial]: ...
def call_udf(udf_name: str, *args: ColumnOrLiteral) -> Column: ...
def call_builtin(function_name: str, *args: ColumnOrLiteral) -> Column: ...
def builtin(function_name: str) -> Callable: ...
def sproc(
    func: Optional[Callable] = ...,
    *,
    return_type: Optional[DataType] = ...,
    input_types: Optional[List[DataType]] = ...,
    name: Optional[Union[str, Iterable[str]]] = ...,
    is_permanent: bool = ...,
    stage_location: Optional[str] = ...,
    imports: Optional[List[Union[str, Tuple[str, str]]]] = ...,
    packages: Optional[List[Union[str, ModuleType]]] = ...,
    replace: bool = ...,
    session: Optional[snowflake.snowpark.Session] = ...,
    parallel: int = ...
) -> Union[StoredProcedure, functools.partial]: ...
