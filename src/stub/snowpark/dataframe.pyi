from typing import Any, Dict, Iterable, List, Optional, Tuple, Union

import snowflake.snowpark
from snowflake.connector.options import pandas
from snowflake.snowpark._internal.sp_types.types_package import (
    ColumnOrName as ColumnOrName,
    LiteralType as LiteralType,
)
from snowflake.snowpark.column import Column
from snowflake.snowpark.dataframe_na_functions import DataFrameNaFunctions
from snowflake.snowpark.dataframe_stat_functions import DataFrameStatFunctions
from snowflake.snowpark.dataframe_writer import DataFrameWriter
from snowflake.snowpark.exceptions import (
    SnowparkClientException as SnowparkClientException,
)
from snowflake.snowpark.row import Row as Row
from snowflake.snowpark.types import StructType

class DataFrame:
    session: Any
    approxQuantile: Any
    corr: Any
    cov: Any
    crosstab: Any
    sampleBy: Any
    dropna: Any
    fillna: Any
    replace: Any
    def __init__(self, session: Any | None = ..., plan: Any | None = ...) -> None: ...
    @staticmethod
    def get_unaliased(col_name: str) -> List[str]: ...
    @property
    def stat(self) -> DataFrameStatFunctions: ...
    def collect(self) -> List[Row]: ...
    def clone(self) -> DataFrame: ...
    def toPandas(self, **kwargs) -> pandas.DataFrame: ...
    def toDF(self, *names: Union[str, List[str], Tuple[str, ...]]) -> DataFrame: ...
    def __getitem__(self, item): ...
    def __getattr__(self, name): ...
    @property
    def columns(self) -> List[str]: ...
    def col(self, col_name: str) -> Column: ...
    def select(
        self, *cols: Union[ColumnOrName, List[ColumnOrName], Tuple[ColumnOrName, ...]]
    ) -> DataFrame: ...
    def drop(
        self, *cols: Union[ColumnOrName, List[ColumnOrName], Tuple[ColumnOrName, ...]]
    ) -> DataFrame: ...
    def filter(self, expr: Column) -> DataFrame: ...
    where: Any
    def sort(
        self,
        *cols: Union[str, Column, List[ColumnOrName], Tuple[ColumnOrName, ...]],
        ascending: Optional[Union[bool, int, List[Union[bool, int]]]] = ...
    ) -> DataFrame: ...
    def agg(
        self,
        exprs: Union[
            Column, Tuple[str, str], List[Column], List[Tuple[str, str]], Dict[str, str]
        ],
    ) -> DataFrame: ...
    def rollup(
        self, *cols: Union[ColumnOrName, List[ColumnOrName], Tuple[ColumnOrName, ...]]
    ) -> snowflake.snowpark.RelationalGroupedDataFrame: ...
    def groupBy(
        self, *cols: Union[ColumnOrName, List[ColumnOrName], Tuple[ColumnOrName, ...]]
    ) -> snowflake.snowpark.RelationalGroupedDataFrame: ...
    def groupByGroupingSets(
        self,
        *grouping_sets: Union[
            snowflake.snowpark.GroupingSets,
            List[snowflake.snowpark.GroupingSets],
            Tuple[snowflake.snowpark.GroupingSets, ...],
        ]
    ) -> snowflake.snowpark.RelationalGroupedDataFrame: ...
    def cube(
        self, *cols: Union[ColumnOrName, List[ColumnOrName], Tuple[ColumnOrName, ...]]
    ) -> snowflake.snowpark.RelationalGroupedDataFrame: ...
    def distinct(self) -> DataFrame: ...
    def pivot(
        self,
        pivot_col: ColumnOrName,
        values: Union[List[LiteralType], Tuple[LiteralType, ...]],
    ) -> snowflake.snowpark.RelationalGroupedDataFrame: ...
    def limit(self, n: int) -> DataFrame: ...
    def union(self, other: DataFrame) -> DataFrame: ...
    def unionAll(self, other: DataFrame) -> DataFrame: ...
    def unionByName(self, other: DataFrame) -> DataFrame: ...
    def unionAllByName(self, other: DataFrame) -> DataFrame: ...
    def intersect(self, other: DataFrame) -> DataFrame: ...
    def except_(self, other: DataFrame) -> DataFrame: ...
    def naturalJoin(
        self, right: DataFrame, join_type: Optional[str] = ...
    ) -> DataFrame: ...
    def join(
        self,
        right: DataFrame,
        using_columns: Optional[Union[ColumnOrName, List[ColumnOrName]]] = ...,
        join_type: Optional[str] = ...,
    ) -> DataFrame: ...
    def joinTableFunction(
        self,
        func_name: Union[str, List[str]],
        *func_arguments: ColumnOrName,
        **func_named_arguments: ColumnOrName
    ) -> DataFrame: ...
    def crossJoin(self, right: DataFrame) -> DataFrame: ...
    def withColumn(self, col_name: str, col: Column) -> DataFrame: ...
    def withColumns(self, col_names: List[str], values: List[Column]) -> DataFrame: ...
    def count(self) -> int: ...
    @property
    def write(self) -> DataFrameWriter: ...
    def copy_into_table(
        self,
        table_name: Union[str, Iterable[str]],
        *,
        files: Optional[Iterable[str]] = ...,
        pattern: Optional[str] = ...,
        validation_mode: Optional[str] = ...,
        target_columns: Optional[Iterable[str]] = ...,
        transformations: Optional[Iterable[Union[Column, str]]] = ...,
        format_type_options: Optional[Dict[str, Any]] = ...,
        **copy_options: Any
    ) -> List[Row]: ...
    def show(self, n: int = ..., max_width: int = ...) -> None: ...
    def flatten(
        self,
        input: ColumnOrName,
        path: Optional[str] = ...,
        outer: bool = ...,
        recursive: bool = ...,
        mode: str = ...,
    ) -> DataFrame: ...
    def createOrReplaceView(
        self, name: Union[str, List[str], Tuple[str, ...]]
    ) -> List[Row]: ...
    def createOrReplaceTempView(
        self, name: Union[str, List[str], Tuple[str, ...]]
    ) -> List[Row]: ...
    def first(self, n: Optional[int] = ...) -> Union[Optional[Row], List[Row]]: ...
    take: Any
    def sample(
        self, frac: Optional[float] = ..., n: Optional[int] = ...
    ) -> DataFrame: ...
    @property
    def na(self) -> DataFrameNaFunctions: ...
    @property
    def schema(self) -> StructType: ...
