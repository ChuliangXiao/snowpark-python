import functools
from typing import Callable, List, Optional, Tuple, Union

from snowflake.snowpark._internal.sp_types.types_package import (
    ColumnOrName as ColumnOrName,
    LiteralType as LiteralType,
)
from snowflake.snowpark.column import CaseExpr, Column
from snowflake.snowpark.types import DataType as DataType
from snowflake.snowpark.udf import UserDefinedFunction as UserDefinedFunction

def col(col_name: str) -> Column: ...
def column(col_name: str) -> Column: ...
def lit(literal: LiteralType) -> Column: ...
def sql_expr(sql: str) -> Column: ...
def approx_count_distinct(e: ColumnOrName) -> Column: ...
def avg(e: ColumnOrName) -> Column: ...
def corr(column1: ColumnOrName, column2: ColumnOrName) -> Column: ...
def count(e: ColumnOrName) -> Column: ...
def count_distinct(*cols: ColumnOrName) -> Column: ...
def covar_pop(column1: ColumnOrName, column2: ColumnOrName) -> Column: ...
def covar_samp(column1: ColumnOrName, column2: ColumnOrName) -> Column: ...
def kurtosis(e: ColumnOrName) -> Column: ...
def max(e: ColumnOrName) -> Column: ...
def mean(e: ColumnOrName) -> Column: ...
def median(e: ColumnOrName) -> Column: ...
def min(e: ColumnOrName) -> Column: ...
def skew(e: ColumnOrName) -> Column: ...
def stddev(e: ColumnOrName) -> Column: ...
def stddev_samp(e: ColumnOrName) -> Column: ...
def stddev_pop(e: ColumnOrName) -> Column: ...
def sum(e: ColumnOrName) -> Column: ...
def sum_distinct(e: ColumnOrName) -> Column: ...
def variance(e: ColumnOrName) -> Column: ...
def var_samp(e: ColumnOrName) -> Column: ...
def var_pop(e: ColumnOrName) -> Column: ...
def approx_percentile(col: ColumnOrName, percentile: float) -> Column: ...
def approx_percentile_accumulate(col: ColumnOrName) -> Column: ...
def approx_percentile_estimate(state: ColumnOrName, percentile: float) -> Column: ...
def approx_percentile_combine(state: ColumnOrName) -> Column: ...
def coalesce(*e: ColumnOrName) -> Column: ...
def equal_nan(e: ColumnOrName) -> Column: ...
def is_null(e: ColumnOrName) -> Column: ...
def negate(e: ColumnOrName) -> Column: ...
def not_(e: ColumnOrName) -> Column: ...
def random(seed: Optional[int] = ...) -> Column: ...
def to_decimal(e: ColumnOrName, precision: int, scale: int) -> Column: ...
def sqrt(e: ColumnOrName) -> Column: ...
def abs(e: ColumnOrName) -> Column: ...
def ceil(e: ColumnOrName) -> Column: ...
def floor(e: ColumnOrName) -> Column: ...
def exp(e: ColumnOrName) -> Column: ...
def log(
    base: Union[ColumnOrName, int, float], x: Union[ColumnOrName, int, float]
) -> Column: ...
def pow(
    l: Union[ColumnOrName, int, float], r: Union[ColumnOrName, int, float]
) -> Column: ...
def split(str: ColumnOrName, pattern: ColumnOrName) -> Column: ...
def substring(
    str: ColumnOrName, pos: Union[Column, int], len: Union[Column, int]
) -> Column: ...
def translate(
    src: ColumnOrName, matching_string: ColumnOrName, replace_string: ColumnOrName
) -> Column: ...
def trim(e: ColumnOrName, trim_string: ColumnOrName) -> Column: ...
def upper(e: ColumnOrName) -> Column: ...
def contains(col: ColumnOrName, string: ColumnOrName) -> Column: ...
def startswith(col: ColumnOrName, str: ColumnOrName) -> Column: ...
def char(col: ColumnOrName) -> Column: ...
def to_time(e: ColumnOrName, fmt: Optional[Column] = ...) -> Column: ...
def to_timestamp(e: ColumnOrName, fmt: Optional[Column] = ...) -> Column: ...
def to_date(e: ColumnOrName, fmt: Optional[Column] = ...) -> Column: ...
def arrays_overlap(array1: ColumnOrName, array2: ColumnOrName) -> Column: ...
def array_intersection(array1: ColumnOrName, array2: ColumnOrName) -> Column: ...
def datediff(part: str, col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def dateadd(part: str, col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def is_array(col: ColumnOrName) -> Column: ...
def is_boolean(col: ColumnOrName) -> Column: ...
def is_binary(col: ColumnOrName) -> Column: ...
def is_char(col: ColumnOrName) -> Column: ...
def is_varchar(col: ColumnOrName) -> Column: ...
def is_date(col: ColumnOrName) -> Column: ...
def is_date_value(col: ColumnOrName) -> Column: ...
def is_decimal(col: ColumnOrName) -> Column: ...
def is_double(col: ColumnOrName) -> Column: ...
def is_real(col: ColumnOrName) -> Column: ...
def is_integer(col: ColumnOrName) -> Column: ...
def is_null_value(col: ColumnOrName) -> Column: ...
def is_object(col: ColumnOrName) -> Column: ...
def is_time(col: ColumnOrName) -> Column: ...
def is_timestamp_ltz(col: ColumnOrName) -> Column: ...
def is_timestamp_ntz(col: ColumnOrName) -> Column: ...
def is_timestamp_tz(col: ColumnOrName) -> Column: ...
def typeof(col: ColumnOrName) -> Column: ...
def check_json(col: ColumnOrName) -> Column: ...
def check_xml(col: ColumnOrName) -> Column: ...
def json_extract_path_text(col: ColumnOrName, path: ColumnOrName) -> Column: ...
def parse_json(e: ColumnOrName) -> Column: ...
def parse_xml(e: ColumnOrName) -> Column: ...
def strip_null_value(col: ColumnOrName) -> Column: ...
def array_agg(col: ColumnOrName) -> Column: ...
def array_append(array: ColumnOrName, element: ColumnOrName) -> Column: ...
def array_cat(array1: ColumnOrName, array2: ColumnOrName) -> Column: ...
def array_compact(array: ColumnOrName) -> Column: ...
def array_construct(*cols: ColumnOrName) -> Column: ...
def array_construct_compact(*cols: ColumnOrName) -> Column: ...
def array_contains(variant: ColumnOrName, array: ColumnOrName) -> Column: ...
def array_insert(
    array: ColumnOrName, pos: ColumnOrName, element: ColumnOrName
) -> Column: ...
def array_position(variant: ColumnOrName, array: ColumnOrName) -> Column: ...
def array_prepend(array: ColumnOrName, element: ColumnOrName) -> Column: ...
def array_size(array: ColumnOrName) -> Column: ...
def array_slice(
    array: ColumnOrName, from_: ColumnOrName, to: ColumnOrName
) -> Column: ...
def array_to_string(array: ColumnOrName, separator: ColumnOrName) -> Column: ...
def object_agg(key: ColumnOrName, value: ColumnOrName) -> Column: ...
def object_construct(*key_values: ColumnOrName) -> Column: ...
def object_construct_keep_null(*key_values: ColumnOrName) -> Column: ...
def object_delete(
    obj: ColumnOrName, key1: ColumnOrName, *keys: ColumnOrName
) -> Column: ...
def object_insert(
    obj: ColumnOrName,
    key: ColumnOrName,
    value: ColumnOrName,
    update_flag: Optional[ColumnOrName] = ...,
) -> Column: ...
def object_pick(obj: ColumnOrName, key1: ColumnOrName, *keys: ColumnOrName): ...
def as_array(variant: ColumnOrName) -> Column: ...
def as_binary(variant: ColumnOrName) -> Column: ...
def as_char(variant: ColumnOrName) -> Column: ...
def as_varchar(variant: ColumnOrName) -> Column: ...
def as_date(variant: ColumnOrName) -> Column: ...
def as_decimal(
    variant: ColumnOrName, precision: Optional[int] = ..., scale: Optional[int] = ...
) -> Column: ...
def as_number(
    variant: ColumnOrName, precision: Optional[int] = ..., scale: Optional[int] = ...
) -> Column: ...
def as_double(variant: ColumnOrName) -> Column: ...
def as_real(variant: ColumnOrName) -> Column: ...
def as_integer(variant: ColumnOrName) -> Column: ...
def as_object(variant: ColumnOrName) -> Column: ...
def as_time(variant: ColumnOrName) -> Column: ...
def as_timestamp_ltz(variant: ColumnOrName) -> Column: ...
def as_timestamp_ntz(variant: ColumnOrName) -> Column: ...
def as_timestamp_tz(variant: ColumnOrName) -> Column: ...
def to_binary(e: ColumnOrName, fmt: Optional[str] = ...) -> Column: ...
def to_array(e: ColumnOrName) -> Column: ...
def to_json(e: ColumnOrName) -> Column: ...
def to_object(e: ColumnOrName) -> Column: ...
def to_variant(e: ColumnOrName) -> Column: ...
def to_xml(e: ColumnOrName) -> Column: ...
def get_ignore_case(obj: ColumnOrName, field: ColumnOrName) -> Column: ...
def object_keys(obj: ColumnOrName) -> Column: ...
def xmlget(
    xml: ColumnOrName, tag: ColumnOrName, instance_num: Union[ColumnOrName, int] = ...
) -> Column: ...
def get_path(col: ColumnOrName, path: ColumnOrName) -> Column: ...
def get(col1: ColumnOrName, col2: ColumnOrName) -> Column: ...
def when(condition: Column, value: Union[Column, LiteralType]) -> CaseExpr: ...
def iff(
    condition: Column,
    expr1: Union[Column, LiteralType],
    expr2: Union[Column, LiteralType],
) -> Column: ...
def cume_dist() -> Column: ...
def rank() -> Column: ...
def percent_rank() -> Column: ...
def dense_rank() -> Column: ...
def row_number() -> Column: ...
def lag(
    e: ColumnOrName,
    offset: int = ...,
    default_value: Optional[Union[Column, LiteralType]] = ...,
) -> Column: ...
def lead(
    e: ColumnOrName,
    offset: int = ...,
    default_value: Optional[Union[Column, LiteralType]] = ...,
) -> Column: ...
def ntile(e: ColumnOrName) -> Column: ...
def udf(
    func: Optional[Callable] = ...,
    *,
    return_type: Optional[DataType] = ...,
    input_types: Optional[List[DataType]] = ...,
    name: Optional[str] = ...,
    is_permanent: bool = ...,
    stage_location: Optional[str] = ...,
    replace: bool = ...,
    parallel: int = ...
) -> Union[UserDefinedFunction, functools.partial]: ...
def call_udf(
    udf_name: str, *cols: Union[ColumnOrName, List[ColumnOrName], Tuple[ColumnOrName]]
) -> Column: ...
def call_builtin(function_name: str, *args: Union[Column, LiteralType]) -> Column: ...
def builtin(function_name: str) -> Callable: ...
